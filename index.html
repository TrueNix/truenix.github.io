<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fancy File Manager (Standalone)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Optional: tweak Tailwind on the fly
    tailwind.config = {
      theme: {
        extend: {}
      }
    }
  </script>
  <style>
    html, body, #root { height: 100%; }
  </style>
</head>
<body class="bg-slate-900">
  <div id="root"></div>

  <!-- React (CDN) + Babel for JSX in-browser. For production, consider prebuilding. -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useEffect, useMemo, useState } = React;

    function App() {
      const [dirHandle, setDirHandle] = useState(null);
      const [entries, setEntries] = useState([]); // {path, handle, kind, size, lastModified}
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState("");
      const [activePath, setActivePath] = useState(null);
      const [activePreview, setActivePreview] = useState({ type: "", text: "", bytes: null });
      const [query, setQuery] = useState("");
      const [searching, setSearching] = useState(false);
      const [searchResults, setSearchResults] = useState([]);
      const [selected, setSelected] = useState(new Set());
      const [ftpOpen, setFtpOpen] = useState(false);
      const [ftpCfg, setFtpCfg] = useState(() => {
        const saved = localStorage.getItem("fancyfm.ftp");
        return (saved && JSON.parse(saved)) || { scheme: "sftp", host: "example.com", port: 22, user: "username", pass: "", remoteDir: "/uploads" };
      });

      useEffect(() => { localStorage.setItem("fancyfm.ftp", JSON.stringify(ftpCfg)); }, [ftpCfg]);

      const supportsFSAccess = !!window.showDirectoryPicker;

      async function pickDirectory() {
        try {
          setError("");
          if (!supportsFSAccess) { setError("This browser doesn't support directory access. Try Chrome or Edge."); return; }
          const handle = await window.showDirectoryPicker({ id: "fancy-fm-root", mode: "read" });
          setDirHandle(handle);
          setLoading(true);
          const list = [];
          await walkDirectory(handle, "", list);
          list.sort((a,b)=> a.path.localeCompare(b.path));
          setEntries(list);
          setLoading(false);
          if (list.length) setActivePath(list[0].path);
        } catch (e) {
          if (e?.name !== "AbortError") setError(String(e));
          setLoading(false);
        }
      }

      async function walkDirectory(handle, base, out) {
        for await (const [name, h] of handle.entries()) {
          const path = base ? `${base}/${name}` : name;
          if (h.kind === "file") {
            try {
              const file = await h.getFile();
              out.push({ path, handle: h, kind: "file", size: file.size, lastModified: file.lastModified });
            } catch (e) {
              out.push({ path, handle: h, kind: "file", size: 0, lastModified: 0 });
            }
          } else if (h.kind === "directory") {
            out.push({ path, handle: h, kind: "directory" });
            await walkDirectory(h, path, out);
          }
        }
      }

      async function preview(path) {
        setActivePath(path);
        const entry = entries.find(e => e.path === path);
        if (!entry || entry.kind !== "file") { setActivePreview({ type: "", text: "", bytes: null }); return; }
        try {
          const file = await getFileFromEntry(entry);
          const type = sniffType(entry.path, file.type);
          if (type === "text") {
            const text = await file.text();
            setActivePreview({ type: "text", text, bytes: null });
          } else if (type === "image") {
            const bytes = await file.arrayBuffer();
            setActivePreview({ type: "image", text: "", bytes });
          } else {
            setActivePreview({ type: "binary", text: `Binary file (size ${file.size.toLocaleString()} bytes)`, bytes: null });
          }
        } catch (e) {
          setActivePreview({ type: "", text: `Cannot open file: ${e}`, bytes: null });
        }
      }

      function handleFileInput(ev){
        const files = Array.from(ev.target.files || []);
        if (!files.length) return;
        loadFromFiles(files);
        // allow re-selecting the same files later
        ev.target.value = "";
      }

      async function loadFromFiles(files){
        try {
          setError("");
          setDirHandle(null);
          setLoading(true);
          const list = [];
          for (const file of files){
            const path = file.webkitRelativePath || file.name;
            list.push({ path, handle: null, kind: "file", size: file.size, lastModified: file.lastModified, fileObj: file });
          }
          list.sort((a,b)=> a.path.localeCompare(b.path));
          setEntries(list);
          setLoading(false);
          if (list.length) setActivePath(list[0].path);
        } catch(e){
          setError(String(e));
          setLoading(false);
        }
      }

      async function getFileFromEntry(e){
        if (e?.fileObj) return e.fileObj; // from manual file picker
        if (e?.handle?.getFile) return await e.handle.getFile();
        throw new Error("Entry has no readable file");
      }

      function sniffType(path, mime) {
        const low = path.toLowerCase();
        if (mime?.startsWith("image/") || /(png|jpe?g|gif|webp|svg)$/.test(low)) return "image";
        if (/(txt|md|json|js|ts|tsx|jsx|py|go|rs|c|cpp|h|java|kt|sh|yml|yaml|toml|ini|env|csv|html|css)$/.test(low) || mime?.startsWith("text/")) return "text";
        return "binary";
      }

      const displayed = React.useMemo(() => {
        if (!query) return entries;
        const q = query.toLowerCase();
        return entries.filter(e => e.path.toLowerCase().includes(q));
      }, [entries, query]);

      function toggleSelect(path) {
        const next = new Set(selected);
        if (next.has(path)) next.delete(path); else next.add(path);
        setSelected(next);
      }

      async function runSearchInFiles(q) {
        if (!q) return;
        setSearching(true);
        setSearchResults([]);
        const results = [];
        const needle = q;
        const re = buildQueryRegex(needle);

        for (const e of entries) {
          if (e.kind !== "file") continue;
          try {
            const file = await getFileFromEntry(e);
            const MAX = 5 * 1024 * 1024; // read first 5MB for perf
            const blob = file.size > MAX ? file.slice(0, MAX) : file;
            const text = await blob.text();
            const lines = text.split(/
?
/);
            const matches = [];
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              if (re.test(line)) {
                const idx = line.toLowerCase().indexOf(needle.toLowerCase());
                const start = Math.max(0, idx - 30);
                const end = Math.min(line.length, idx + needle.length + 30);
                const snippet = line.slice(start, end);
                matches.push({ line: i + 1, idx, snippet });
              }
            }
            if (matches.length) results.push({ path: e.path, matches });
          } catch {}
        }
        setSearchResults(results);
        setSearching(false);
      }

      function buildQueryRegex(q) {
        try {
          if (q.startsWith("/") && q.endsWith("/")) { return new RegExp(q.slice(1, -1)); }
        } catch {}
        return new RegExp(q.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "i");
      }

      function humanSize(n) {
        if (n == null) return "";
        const units = ["B","KB","MB","GB","TB"]; let i=0; let x=n;
        while (x >= 1024 && i < units.length-1) { x /= 1024; i++; }
        return `${x.toFixed(x<10?2:x<100?1:0)} ${units[i]}`;
      }

      function copy(text) { navigator.clipboard.writeText(text); }

      const ftpCommand = React.useMemo(() => {
        const items = [...selected];
        if (items.length === 0) return "# Select one or more files to generate upload commands";
        const { scheme, host, port, user, pass, remoteDir } = ftpCfg;
        const auth = pass ? `${user}:${pass}` : `${user}`;
        if (scheme === "ftp") {
          return `# FTP (unencrypted). Consider FTPS or SFTP instead.
` +
                 `# Upload selected files (passive mode)
` +
                 `curl --ftp-pasv -T {${items.join(",")}} ftp://${auth}@${host}:${port}${remoteDir}/
`;
        }
        // SFTP default
        return `# SFTP (recommended) — uploads each file
` +
               items.map(p => `curl -T "${p}" sftp://${auth}@${host}:${port}${remoteDir}/`).join("
");
      }, [selected, ftpCfg]);

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 text-slate-100">
          <header className="px-6 py-4 border-b border-slate-700/50 sticky top-0 backdrop-blur">
            <div className="flex items-center gap-3">
              <h1 className="text-2xl font-semibold tracking-tight">Fancy File Manager</h1>
              <span className="text-xs opacity-70">Local • Private • Search • FTP helper</span>
            </div>
            <div className="mt-3 flex flex-wrap gap-2 items-center">
              <button onClick={pickDirectory} className="px-3 py-2 rounded-xl bg-indigo-500 hover:bg-indigo-600 active:translate-y-px transition shadow">{supportsFSAccess ? "Choose Folder" : "Choose Folder"}</button>

              {/* Manual files/folder picker (works everywhere). webkitdirectory lets you pick a folder in Chromium and returns files. */}
              <label className="px-3 py-2 rounded-xl bg-sky-600 hover:bg-sky-700 cursor-pointer" htmlFor="filePicker">Choose Files / Folder</label>
              <input id="filePicker" type="file" multiple webkitdirectory onChange={handleFileInput} className="hidden" />

              <div className="relative">
                <input value={query} onChange={e=>setQuery(e.target.value)} placeholder="Filter by name (Type /regex/ for regex)" className="px-3 py-2 rounded-xl bg-slate-700/60 focus:bg-slate-700 outline-none w-80" />
              </div>
              <button onClick={()=> runSearchInFiles(query || prompt("Search text (supports /regex/):", query) || "")} disabled={!entries.length || searching} className="px-3 py-2 rounded-xl bg-emerald-500/90 hover:bg-emerald-600 disabled:opacity-40">Search in files</button>
              <button onClick={()=> setFtpOpen(true)} disabled={!selected.size} className="px-3 py-2 rounded-xl bg-fuchsia-500/90 hover:bg-fuchsia-600 disabled:opacity-40">FTP / SFTP…</button>
              {error && <span className="text-red-300 ml-3">{error}</span>}
            </div>
          </header>

          <main className="grid grid-cols-12 gap-4 p-4">
            <aside className="col-span-4 lg:col-span-3 xl:col-span-3 2xl:col-span-2">
              <div className="rounded-2xl border border-slate-700/60 overflow-hidden">
                <div className="px-4 py-2 bg-slate-800/60 text-sm border-b border-slate-700/50 flex justify-between">
                  <span>Files {entries.length? `(${entries.length})`: ""}</span>
                  {loading && <span className="animate-pulse">Loading…</span>}
                </div>
                <div className="max-h-[70vh] overflow-auto divide-y divide-slate-700/40">
                  {displayed.map((e)=> (
                    <div key={e.path} className={`px-3 py-2 text-sm cursor-pointer hover:bg-slate-800/60 ${activePath===e.path?"bg-slate-800/80": ""}`} onClick={()=> preview(e.path)} onDoubleClick={()=> toggleSelect(e.path)}>
                      <div className="flex items-center gap-2">
                        <span className="text-slate-400">{e.kind === 'directory' ? '📁' : '📄'}</span>
                        <span className="truncate" title={e.path}>{e.path}</span>
                      </div>
                      {e.kind === 'file' && (
                        <div className="text-[11px] text-slate-400 ml-6 flex gap-2">
                          <span>{humanSize(e.size)}</span>
                          {e.lastModified ? <span>• {new Date(e.lastModified).toLocaleString()}</span> : null}
                        </div>
                      )}
                      {selected.has(e.path) && <div className="ml-6 text-[10px] text-emerald-300">selected</div>}
                    </div>
                  ))}
                  {!entries.length && (
                    <div className="p-4 text-sm text-slate-400">Click <b>Choose Folder</b> to grant read access to a directory. This stays on your device.</div>
                  )}
                </div>
              </div>
            </aside>

            <section className="col-span-8 lg:col-span-9 xl:col-span-9 2xl:col-span-10">
              <div className="rounded-2xl border border-slate-700/60 overflow-hidden">
                <div className="px-4 py-2 bg-slate-800/60 text-sm border-b border-slate-700/50 flex items-center gap-3">
                  <span className="opacity-80">Preview</span>
                  {activePath && <span className="text-xs text-slate-400 truncate">{activePath}</span>}
                  {activePath && (
                    <button onClick={()=> toggleSelect(activePath)} className="ml-auto text-xs px-2 py-1 rounded-lg bg-slate-700/70 hover:bg-slate-700">
                      {selected.has(activePath)? "Unselect" : "Select"}
                    </button>
                  )}
                </div>

                <div className="p-4 max-h-[70vh] overflow-auto">
                  {!activePath && <div className="text-slate-400">Pick a file to preview.</div>}
                  {activePreview.type === "text" && (
                    <pre className="whitespace-pre-wrap text-sm leading-5">{activePreview.text}</pre>
                  )}
                  {activePreview.type === "image" && activePreview.bytes && (
                    <img className="max-w-full" src={URL.createObjectURL(new Blob([activePreview.bytes]))} />
                  )}
                  {activePreview.type === "binary" && (
                    <div className="text-slate-300 text-sm">{activePreview.text}</div>
                  )}
                </div>
              </div>

              {searchResults.length > 0 && (
                <div className="mt-4 rounded-2xl border border-slate-700/60 overflow-hidden">
                  <div className="px-4 py-2 bg-slate-800/60 text-sm border-b border-slate-700/50 flex items-center">
                    <span className="opacity-80">Search results</span>
                    <span className="ml-2 text-xs text-slate-400">{searchResults.length} files</span>
                    <button className="ml-auto text-xs px-2 py-1 rounded-lg bg-slate-700/70 hover:bg-slate-700" onClick={()=> setSearchResults([])}>Clear</button>
                  </div>
                  <div className="max-h-[40vh] overflow-auto divide-y divide-slate-700/40">
                    {searchResults.map(r => (
                      <div key={r.path} className="px-4 py-2 text-sm">
                        <div className="flex items-center gap-2">
                          <button className="text-indigo-300 hover:underline" onClick={()=> preview(r.path)}>{r.path}</button>
                          <button className="text-[11px] px-2 py-0.5 rounded bg-slate-700/70 hover:bg-slate-700" onClick={()=> toggleSelect(r.path)}>
                            {selected.has(r.path)? "Unselect" : "Select"}
                          </button>
                        </div>
                        <ul className="mt-1 text-slate-400 text-[12px] grid gap-1">
                          {r.matches.slice(0,5).map((m, i)=> (
                            <li key={i}>line {m.line}: <code className="bg-slate-800/70 px-1 rounded">…{m.snippet}…</code></li>
                          ))}
                          {r.matches.length > 5 && <li className="opacity-70">and {r.matches.length - 5} more…</li>}
                        </ul>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </section>
          </main>

          {ftpOpen && (
            <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4" onClick={()=> setFtpOpen(false)}>
              <div className="w-full max-w-3xl rounded-2xl border border-slate-700/60 bg-slate-900" onClick={e=>e.stopPropagation()}>
                <div className="px-4 py-3 border-b border-slate-700/50 flex items-center">
                  <h2 className="text-lg font-semibold">FTP / SFTP Upload Helper</h2>
                  <button className="ml-auto text-slate-400 hover:text-white" onClick={()=> setFtpOpen(false)}>✕</button>
                </div>
                <div className="p-4 grid gap-3">
                  <div className="grid grid-cols-6 gap-3">
                    <div className="col-span-2">
                      <label className="text-xs text-slate-400">Protocol</label>
                      <select value={ftpCfg.scheme} onChange={e=> setFtpCfg({...ftpCfg, scheme: e.target.value})} className="w-full px-3 py-2 rounded-xl bg-slate-800/80">
                        <option value="sftp">SFTP (recommended)</option>
                        <option value="ftp">FTP (insecure)</option>
                      </select>
                    </div>
                    <div>
                      <label className="text-xs text-slate-400">Host</label>
                      <input value={ftpCfg.host} onChange={e=> setFtpCfg({...ftpCfg, host: e.target.value})} className="w-full px-3 py-2 rounded-xl bg-slate-800/80" />
                    </div>
                    <div>
                      <label className="text-xs text-slate-400">Port</label>
                      <input type="number" value={ftpCfg.port} onChange={e=> setFtpCfg({...ftpCfg, port: Number(e.target.value)})} className="w-full px-3 py-2 rounded-xl bg-slate-800/80" />
                    </div>
                    <div>
                      <label className="text-xs text-slate-400">User</label>
                      <input value={ftpCfg.user} onChange={e=> setFtpCfg({...ftpCfg, user: e.target.value})} className="w-full px-3 py-2 rounded-xl bg-slate-800/80" />
                    </div>
                    <div>
                      <label className="text-xs text-slate-400">Password (optional)</label>
                      <input type="password" value={ftpCfg.pass} onChange={e=> setFtpCfg({...ftpCfg, pass: e.target.value})} className="w-full px-3 py-2 rounded-xl bg-slate-800/80" />
                    </div>
                  </div>
                  <div className="grid grid-cols-6 gap-3">
                    <div className="col-span-3">
                      <label className="text-xs text-slate-400">Remote directory</label>
                      <input value={ftpCfg.remoteDir} onChange={e=> setFtpCfg({...ftpCfg, remoteDir: e.target.value})} className="w-full px-3 py-2 rounded-xl bg-slate-800/80" />
                    </div>
                    <div className="col-span-3 flex items-end">
                      <span className="text-xs text-slate-400">Selected files: {selected.size}</span>
                    </div>
                  </div>
                  <div>
                    <label className="text-xs text-slate-400">Generated command(s)</label>
                    <textarea readOnly value={ftpCommand} className="w-full h-40 px-3 py-2 rounded-xl bg-slate-800/80 font-mono text-xs"></textarea>
                    <div className="mt-2 flex gap-2">
                      <button className="px-3 py-2 rounded-xl bg-indigo-500 hover:bg-indigo-600" onClick={()=> copy(ftpCommand)}>Copy</button>
                      <a className="px-3 py-2 rounded-xl bg-slate-700 hover:bg-slate-600" href="https://curl.se/docs/manpage.html" target="_blank" rel="noreferrer">curl manual ↗</a>
                    </div>
                    <p className="text-[11px] text-slate-400 mt-2">Tip: open a terminal in the chosen folder and paste these commands. For SFTP you'll be prompted for a password if not provided.</p>
                  </div>
                </div>
              </div>
            </div>
          )}

          <footer className="p-4 text-center text-xs text-slate-400/80">
            Works best on Chrome/Edge over HTTPS or localhost (File System Access API). Double‑click a file to toggle selection.
          </footer>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
