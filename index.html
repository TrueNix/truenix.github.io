<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fancy File Manager (Standalone)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body, #root { height: 100%; }
  </style>
</head>
<body class="bg-slate-900">
  <div id="root"></div>

  <!-- React (CDN) + Babel for JSX in-browser. For production, consider prebuilding. -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useEffect, useMemo, useState } = React;

    function App() {
      const [dirHandle, setDirHandle] = useState(null);
      const [entries, setEntries] = useState([]);
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState("");
      const [activePath, setActivePath] = useState(null);
      const [activePreview, setActivePreview] = useState({ type: "", text: "", bytes: null });
      const [query, setQuery] = useState("");
      const [searching, setSearching] = useState(false);
      const [searchResults, setSearchResults] = useState([]);
      const [selected, setSelected] = useState(new Set());
      const [ftpOpen, setFtpOpen] = useState(false);
      const [ftpCfg, setFtpCfg] = useState(() => {
        const saved = localStorage.getItem("fancyfm.ftp");
        return (saved && JSON.parse(saved)) || { scheme: "sftp", host: "example.com", port: 22, user: "username", pass: "", remoteDir: "/uploads" };
      });

      useEffect(() => { localStorage.setItem("fancyfm.ftp", JSON.stringify(ftpCfg)); }, [ftpCfg]);

      const supportsFSAccess = !!window.showDirectoryPicker;

      async function pickDirectory() {
        try {
          setError("");
          if (!supportsFSAccess) { setError("This browser doesn't support directory access. Try Chrome or Edge."); return; }
          const handle = await window.showDirectoryPicker({ id: "fancy-fm-root", mode: "read" });
          setDirHandle(handle);
          setLoading(true);
          const list = [];
          await walkDirectory(handle, "", list);
          list.sort((a,b)=> a.path.localeCompare(b.path));
          setEntries(list);
          setLoading(false);
          if (list.length) setActivePath(list[0].path);
        } catch (e) {
          if (e?.name !== "AbortError") setError(String(e));
          setLoading(false);
        }
      }

      async function walkDirectory(handle, base, out) {
        for await (const [name, h] of handle.entries()) {
          const path = base ? `${base}/${name}` : name;
          if (h.kind === "file") {
            try {
              const file = await h.getFile();
              out.push({ path, handle: h, kind: "file", size: file.size, lastModified: file.lastModified });
            } catch (e) {
              out.push({ path, handle: h, kind: "file", size: 0, lastModified: 0 });
            }
          } else if (h.kind === "directory") {
            out.push({ path, handle: h, kind: "directory" });
            await walkDirectory(h, path, out);
          }
        }
      }

      async function preview(path) {
        setActivePath(path);
        const entry = entries.find(e => e.path === path);
        if (!entry || entry.kind !== "file") { setActivePreview({ type: "", text: "", bytes: null }); return; }
        try {
          const file = await getFileFromEntry(entry);
          const type = sniffType(entry.path, file.type);
          if (type === "text") {
            const text = await file.text();
            setActivePreview({ type: "text", text, bytes: null });
          } else if (type === "image") {
            const bytes = await file.arrayBuffer();
            setActivePreview({ type: "image", text: "", bytes });
          } else {
            setActivePreview({ type: "binary", text: `Binary file (size ${file.size.toLocaleString()} bytes)`, bytes: null });
          }
        } catch (e) {
          setActivePreview({ type: "", text: `Cannot open file: ${e}`, bytes: null });
        }
      }

      function handleFileInput(ev){
        const files = Array.from(ev.target.files || []);
        if (!files.length) return;
        loadFromFiles(files);
        ev.target.value = "";
      }

      async function loadFromFiles(files){
        try {
          setError("");
          setDirHandle(null);
          setLoading(true);
          const list = [];
          for (const file of files){
            const path = file.webkitRelativePath || file.name;
            list.push({ path, handle: null, kind: "file", size: file.size, lastModified: file.lastModified, fileObj: file });
          }
          list.sort((a,b)=> a.path.localeCompare(b.path));
          setEntries(list);
          setLoading(false);
          if (list.length) setActivePath(list[0].path);
        } catch(e){
          setError(String(e));
          setLoading(false);
        }
      }

      async function getFileFromEntry(e){
        if (e?.fileObj) return e.fileObj;
        if (e?.handle?.getFile) return await e.handle.getFile();
        throw new Error("Entry has no readable file");
      }

      function sniffType(path, mime) {
        const low = path.toLowerCase();
        if (mime?.startsWith("image/") || /(png|jpe?g|gif|webp|svg)$/.test(low)) return "image";
        if (/(txt|md|json|js|ts|tsx|jsx|py|go|rs|c|cpp|h|java|kt|sh|yml|yaml|toml|ini|env|csv|html|css)$/.test(low) || mime?.startsWith("text/")) return "text";
        return "binary";
      }

      const displayed = useMemo(() => {
        if (!query) return entries;
        const q = query.toLowerCase();
        return entries.filter(e => e.path.toLowerCase().includes(q));
      }, [entries, query]);

      function toggleSelect(path) {
        const next = new Set(selected);
        if (next.has(path)) next.delete(path); else next.add(path);
        setSelected(next);
      }

      async function runSearchInFiles(q) {
        if (!q) return;
        setSearching(true);
        setSearchResults([]);
        const results = [];
        const needle = q;
        const re = buildQueryRegex(needle);

        for (const e of entries) {
          if (e.kind !== "file") continue;
          try {
            const file = await getFileFromEntry(e);
            const MAX = 5 * 1024 * 1024;
            const blob = file.size > MAX ? file.slice(0, MAX) : file;
            const text = await blob.text();
            const lines = text.split(/\r?\n/);
            const matches = [];
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              if (re.test(line)) {
                const idx = line.toLowerCase().indexOf(needle.toLowerCase());
                const start = Math.max(0, idx - 30);
                const end = Math.min(line.length, idx + needle.length + 30);
                const snippet = line.slice(start, end);
                matches.push({ line: i + 1, idx, snippet });
              }
            }
            if (matches.length) results.push({ path: e.path, matches });
          } catch {}
        }
        setSearchResults(results);
        setSearching(false);
      }

      function buildQueryRegex(q) {
        try {
          if (q.startsWith("/") && q.endsWith("/")) { return new RegExp(q.slice(1, -1)); }
        } catch {}
        return new RegExp(q.replace(/[.*+?^${}()|[\\]\\]/g, "\\$&"), "i");
      }

      function humanSize(n) {
        if (n == null) return "";
        const units = ["B","KB","MB","GB","TB"]; let i=0; let x=n;
        while (x >= 1024 && i < units.length-1) { x /= 1024; i++; }
        return `${x.toFixed(x<10?2:x<100?1:0)} ${units[i]}`;
      }

      function copy(text) { navigator.clipboard.writeText(text); }

      const ftpCommand = useMemo(() => {
        const items = [...selected];
        if (items.length === 0) return "# Select one or more files to generate upload commands";
        const { scheme, host, port, user, pass, remoteDir } = ftpCfg;
        const auth = pass ? `${user}:${pass}` : `${user}`;
        if (scheme === "ftp") {
          return `# FTP (unencrypted). Consider FTPS or SFTP instead.\n` +
                 `# Upload selected files (passive mode)\n` +
                 `curl --ftp-pasv -T {${items.join(",")}} ftp://${auth}@${host}:${port}${remoteDir}/\n`;
        }
        return `# SFTP (recommended) â€” uploads each file\n` +
               items.map(p => `curl -T "${p}" sftp://${auth}@${host}:${port}${remoteDir}/`).join("\n");
      }, [selected, ftpCfg]);

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 text-slate-100">
          {/* header, main, and rest of UI unchanged from your version */}
          {/* ... keep your existing JSX layout ... */}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
