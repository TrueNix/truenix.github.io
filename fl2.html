<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Folder Uploader ‚Ä¢ Dark</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #131a22;
      --panel-2: #0f151d;
      --text: #e8eef5;
      --muted: #a7b1bd;
      --accent: #6ea8fe;
      --danger: #ff6b6b;
      --ok: #6bff95;
      --border: #1f2a36;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 14px;
    }
    * { box-sizing: border-box }
    body {
      margin: 0; background: var(--bg); color: var(--text);
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
    }
    header {
      padding: 24px; display: flex; gap: 16px; align-items: center; justify-content: space-between;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, #0d1218, #0a0e13 80%);
      position: sticky; top: 0; z-index: 2;
    }
    header h1 { margin: 0; font-size: 18px; font-weight: 600; letter-spacing: .2px; }
    .wrap {
      max-width: 1100px; margin: 24px auto; padding: 0 16px 60px;
      display: grid; grid-template-columns: 360px 1fr; gap: 18px;
    }
    .card {
      background: var(--panel); border: 1px solid var(--border);
      border-radius: var(--radius); box-shadow: var(--shadow);
    }
    .card h2 { margin: 0; padding: 16px 16px 0; font-size: 14px; color: var(--muted); font-weight: 600; text-transform: uppercase; letter-spacing: .8px; }
    .card .body { padding: 16px; }
    label { display: block; font-size: 12px; color: var(--muted); margin: 10px 0 6px; }
    input[type=text], input[type=number], input[type=url], select {
      width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid var(--border);
      background: var(--panel-2); color: var(--text); outline: none;
    }
    input[type=file] { width: 100%; }
    .hint { font-size: 12px; color: var(--muted); margin-top: 6px }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .btn {
      display: inline-flex; align-items: center; justify-content: center; gap: 8px;
      padding: 10px 14px; border-radius: 10px; border: 1px solid var(--border);
      background: var(--accent); color: #0a0f16; font-weight: 700; cursor: pointer; user-select: none;
      transition: transform .06s ease, filter .2s ease; text-decoration: none;
    }
    .btn:active { transform: translateY(1px) }
    .btn.secondary { background: #223049; color: var(--text) }
    .btn.ghost { background: transparent; color: var(--text) }
    .danger { color: var(--danger) }
    .ok { color: var(--ok) }
    .drop {
      border: 1px dashed #2b394a; border-radius: 12px; background: #0c1219;
      padding: 18px; text-align: center; color: var(--muted);
    }
    .drop.dragover { background: #0f1722; border-color: var(--accent); color: var(--text) }
    .stats { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 8px; color: var(--muted); font-size: 12px }
    .stat { background: #0e1520; border: 1px solid var(--border); padding: 6px 10px; border-radius: 999px }
    .tree { max-height: 580px; overflow: auto; padding: 8px; background: #0b1118; border-radius: 12px; border: 1px solid var(--border) }
    .tree details { padding-left: 10px }
    .tree summary { cursor: pointer; }
    .file { display: flex; justify-content: space-between; gap: 12px; padding: 4px 0; color: #c7d1de }
    progress { width: 100%; height: 10px; }
    .bar { height: 10px; width: 100%; background: #0f1722; border: 1px solid var(--border); border-radius: 999px; overflow: hidden }
    .bar > i { display: block; height: 100%; width: 0%; background: linear-gradient(90deg, #6ea8fe, #8fd3ff); }
    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; line-height: 1.5; }
    .log pre { margin: 0; white-space: pre-wrap; }
    footer { max-width: 1100px; margin: 20px auto 80px; padding: 0 16px; color: var(--muted); }
    .pill { font-size: 11px; color: var(--muted); background: #0e1520; border: 1px solid var(--border); padding: 4px 8px; border-radius: 999px; }
    .inline { display: inline-flex; align-items: center; gap: 6px }
    .mt8 { margin-top: 8px } .mt12 { margin-top: 12px } .mt16 { margin-top: 16px } .mt24 { margin-top: 24px }
    .right { text-align: right }
    .nowrap { white-space: nowrap }
    .checkbox { display: flex; align-items: center; gap: 8px; color: var(--muted); font-size: 12px; }
    .checkbox input { width: 16px; height: 16px; }
  </style>
</head>
<body>
  <header>
    <h1>üìÅ Folder Uploader</h1>
    <span class="pill inline">Dark ‚Ä¢ Static ‚Ä¢ No build</span>
  </header>

  <div class="wrap">
    <!-- Left: Controls -->
    <section class="card">
      <h2>Pick folder & configure</h2>
      <div class="body">
        <label>Folder</label>
        <input id="picker" type="file" webkitdirectory directory multiple />
        <div class="hint">You can also drag & drop a folder into the area on the right (Chromium-based browsers).</div>

        <div class="mt16 row">
          <div>
            <label>Protocol</label>
            <select id="protocol">
              <option value="https">https</option>
              <option value="http">http</option>
            </select>
          </div>
          <div>
            <label>Port</label>
            <input id="port" type="number" inputmode="numeric" placeholder="443 or 8443" />
          </div>
        </div>

        <label class="mt8">Server IP / Hostname</label>
        <input id="host" type="text" placeholder="10.0.0.12 or files.example.com" />

        <label class="mt8">Endpoint path</label>
        <input id="path" type="text" value="/upload" />

        <label class="mt8">Auth token (optional)</label>
        <input id="token" type="text" placeholder="Bearer or simple token" />

        <div class="checkbox mt12">
          <input id="preserve" type="checkbox" checked />
          <label for="preserve">Preserve original folder structure on server</label>
        </div>

        <div class="checkbox mt8">
          <input id="batching" type="checkbox" checked />
          <label for="batching">Batch files (speeds up uploads for many small files)</label>
        </div>

        <div class="checkbox mt8">
          <input id="parallel" type="checkbox" checked />
          <label for="parallel">Parallel requests (4 at a time)</label>
        </div>

        <div class="mt16 row">
          <button id="start" class="btn">‚¨ÜÔ∏è Upload</button>
          <button id="clear" class="btn secondary">üßπ Clear</button>
        </div>

        <div class="stats" id="stats"></div>

        <div class="mt16">
          <div class="bar"><i id="overallBar"></i></div>
          <div class="hint mt8" id="overallText">No files selected</div>
        </div>

        <div class="hint mt12">
          Tip: If your static page is on <b>https://*.github.io</b>, your server must be <b>HTTPS</b> (self-signed is OK) to avoid mixed-content blocking.
        </div>
      </div>
    </section>

    <!-- Right: Explorer & status -->
    <section class="card">
      <h2>Local file explorer</h2>
      <div class="body">
        <div id="drop" class="drop">Drag & drop a folder here</div>
        <div class="stats mt12">
          <span class="stat"><span id="fileCount">0</span> files</span>
          <span class="stat"><span id="folderCount">0</span> folders</span>
          <span class="stat"><span id="totalSize">0 B</span> total</span>
        </div>
        <div class="tree mt12" id="tree"></div>
      </div>
    </section>

    <!-- Full-width: logs -->
    <section class="card" style="grid-column: 1 / -1;">
      <h2>Upload log</h2>
      <div class="body log" id="log"><pre></pre></div>
    </section>
  </div>

  <footer>
    <span class="inline">Status: <span id="status" class="pill">idle</span></span>
    <div class="mt12">This tool uses the <code>webkitdirectory</code> attribute and the <code>webkitRelativePath</code> field to preserve folder structure on upload.</div>
  </footer>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const $$ = s => Array.from(document.querySelectorAll(s));
  const picker = $('#picker');
  const drop = $('#drop');
  const treeEl = $('#tree');
  const fileCountEl = $('#fileCount');
  const folderCountEl = $('#folderCount');
  const totalSizeEl = $('#totalSize');
  const stats = $('#stats');
  const overallBar = $('#overallBar');
  const overallText = $('#overallText');
  const logEl = $('#log pre');
  const statusEl = $('#status');

  const inputs = {
    protocol: $('#protocol'),
    host: $('#host'),
    port: $('#port'),
    path: $('#path'),
    token: $('#token'),
    preserve: $('#preserve'),
    batching: $('#batching'),
    parallel: $('#parallel'),
  };

  let files = []; // {file, relPath}
  let totalBytes = 0;

  function humanBytes(n) {
    const u = ['B','KB','MB','GB','TB'];
    let i = 0;
    while (n >= 1024 && i < u.length-1) { n/=1024; i++; }
    return `${n.toFixed(n<10&&i>0?2:1)} ${u[i]}`;
  }

  function log(line, cls='') {
    const t = new Date().toLocaleTimeString();
    logEl.textContent += `[${t}] ${line}\n`;
    logEl.parentElement.scrollTop = logEl.parentElement.scrollHeight;
  }

  function buildTree(list) {
    const root = {};
    for (const f of list) {
      const parts = f.relPath.split('/').filter(Boolean);
      let node = root;
      for (let i=0;i<parts.length;i++) {
        const p = parts[i];
        const isFile = (i === parts.length-1);
        if (isFile) {
          node[p] = { __file: f };
        } else {
          node[p] = node[p] || {};
          node = node[p];
        }
      }
    }
    return root;
  }

  function renderTree(node, base='') {
    const frag = document.createDocumentFragment();
    const keys = Object.keys(node).sort((a,b) => {
      const A = node[a].__file ? 1 : 0;
      const B = node[b].__file ? 1 : 0;
      return A - B || a.localeCompare(b);
    });

    for (const key of keys) {
      const v = node[key];
      if (v.__file) {
        const div = document.createElement('div');
        div.className = 'file';
        const left = document.createElement('span');
        left.textContent = key;
        const right = document.createElement('span');
        right.className = 'nowrap';
        right.textContent = humanBytes(v.__file.file.size);
        div.append(left, right);
        frag.append(div);
      } else {
        const details = document.createElement('details');
        details.open = base === '';// open top-level
        const summary = document.createElement('summary');
        summary.textContent = key;
        details.append(summary, renderTree(v, base + key + '/'));
        frag.append(details);
      }
    }
    const container = document.createElement('div');
    container.append(frag);
    return container;
  }

  function recalc() {
    fileCountEl.textContent = files.length.toString();
    const folders = new Set(files.map(f => f.relPath.split('/').slice(0,-1).join('/'))).size;
    folderCountEl.textContent = (folders || 0).toString();
    totalBytes = files.reduce((a,b)=>a + (b.file?.size||0), 0);
    totalSizeEl.textContent = humanBytes(totalBytes);
    const tree = buildTree(files);
    treeEl.innerHTML = '';
    treeEl.append(renderTree(tree));
    overallBar.style.width = '0%';
    overallText.textContent = files.length ? `Ready: ${files.length} files, ${humanBytes(totalBytes)}` : 'No files selected';
  }

  function addFromInput(fileList) {
    const arr = Array.from(fileList);
    const mapped = arr.map(f => ({
      file: f,
      relPath: f.webkitRelativePath || f.name
    }));
    files = mapped;
    recalc();
    log(`Selected ${files.length} files.`);
  }

  // Drag & drop (Chrome/Edge: dropping a folder works)
  drop.addEventListener('dragover', e => { e.preventDefault(); drop.classList.add('dragover'); });
  drop.addEventListener('dragleave', () => drop.classList.remove('dragover'));
  drop.addEventListener('drop', async e => {
    e.preventDefault(); drop.classList.remove('dragover');
    // Best effort: if user drops files (not directory entries), take them as-is
    if (e.dataTransfer.items) {
      const entries = Array.from(e.dataTransfer.items).map(i => i.webkitGetAsEntry?.()).filter(Boolean);
      if (entries.length && entries.some(en => en.isDirectory)) {
        // Traverse directories
        const gathered = [];
        async function walk(entry, prefix='') {
          if (entry.isFile) {
            await new Promise(resolve => entry.file(f => {
              gathered.push({ file: f, relPath: prefix + entry.name });
              resolve();
            }));
          } else if (entry.isDirectory) {
            const reader = entry.createReader();
            const batch = await new Promise(resolve => reader.readEntries(resolve));
            for (const en of batch) await walk(en, prefix + entry.name + '/');
          }
        }
        for (const en of entries) await walk(en, '');
        files = gathered;
      } else {
        // Plain files (no directories)
        files = Array.from(e.dataTransfer.files).map(f => ({ file: f, relPath: f.name }));
      }
    } else {
      files = Array.from(e.dataTransfer.files).map(f => ({ file: f, relPath: f.name }));
    }
    recalc();
    log(`Selected ${files.length} files via drag & drop.`);
  });

  picker.addEventListener('change', e => {
    addFromInput(e.target.files);
  });

  $('#clear').addEventListener('click', () => {
    files = [];
    picker.value = '';
    recalc();
    log('Cleared selection.');
  });

  function validateTarget() {
    const proto = inputs.protocol.value;
    const host = inputs.host.value.trim();
    const port = (inputs.port.value || '').trim();
    const path = inputs.path.value.trim() || '/upload';
    if (!host) throw new Error('Enter a server IP / hostname.');
    if (!port) throw new Error('Enter a port.');
    if (location.protocol === 'https:' && proto === 'http') {
      throw new Error('This page is https, but target is http ‚Üí blocked by browser. Use https backend or open this page over http locally.');
    }
    const url = `${proto}://${host}:${port}${path.startsWith('/')?path:'/'+path}`;
    return { url, proto, host, port, path };
  }

  async function uploadAll() {
    if (files.length === 0) { log('No files to upload.'); return; }
    let target;
    try { target = validateTarget(); }
    catch (e) { log(`‚ùå ${e.message}`); return; }

    const preserve = inputs.preserve.checked;
    const batching = inputs.batching.checked;
    const parallel = inputs.parallel.checked;
    const token = inputs.token.value.trim();

    statusEl.textContent = 'uploading‚Ä¶';
    const started = Date.now();
    let sentBytes = 0, uploadedFiles = 0;

    const setOverall = () => {
      const pct = totalBytes ? Math.min(100, (sentBytes/totalBytes)*100) : 0;
      overallBar.style.width = `${pct}%`;
      overallText.textContent = `Uploaded ${uploadedFiles}/${files.length} ‚Ä¢ ${humanBytes(sentBytes)} / ${humanBytes(totalBytes)} (${pct.toFixed(1)}%)`;
    };

    // Create jobs (batches or per-file)
    const BATCH_SIZE = 50;
    let jobs = [];
    if (batching) {
      for (let i=0;i<files.length;i+=BATCH_SIZE) {
        jobs.push(files.slice(i, i+BATCH_SIZE));
      }
    } else {
      jobs = files.map(f => [f]);
    }

    const queue = jobs.map(batch => async () => {
      const fd = new FormData();
      const manifest = batch.map(f => ({
        name: f.file.name,
        relPath: f.relPath,
        size: f.file.size,
        type: f.file.type || 'application/octet-stream'
      }));
      fd.append('manifest', new Blob([JSON.stringify(manifest)], { type: 'application/json' }), 'manifest.json');
      for (const f of batch) {
        // Use relPath as filename to preserve structure if backend opts-in
        const filename = preserve ? f.relPath : f.file.name;
        fd.append('files', f.file, filename);
      }

      const headers = {};
      if (token) headers['X-Upload-Token'] = token;

      const res = await fetch(target.url, { method: 'POST', body: fd, headers });
      if (!res.ok) {
        const msg = await res.text().catch(()=>res.statusText);
        throw new Error(`${res.status} ${res.statusText}: ${msg}`);
      }
      const body = await res.json().catch(()=>({ok:true}));
      // Update counters
      for (const f of batch) { sentBytes += f.file.size; uploadedFiles += 1; }
      setOverall();
      return body;
    });

    // Run with limited parallelism
    const CONC = parallel ? 4 : 1;
    let i = 0, errors = 0;
    async function worker() {
      while (i < queue.length) {
        const idx = i++;
        try {
          const out = await queue[idx]();
          log(`‚úÖ Batch ${idx+1}/${queue.length} ok (${out?.saved ?? 'saved'})`);
        } catch (err) {
          errors++;
          log(`‚ùå Batch ${idx+1}/${queue.length} failed: ${err.message}`);
        }
      }
    }
    const workers = Array.from({length: CONC}, worker);
    await Promise.all(workers);

    const elapsed = ((Date.now()-started)/1000).toFixed(1);
    statusEl.textContent = errors ? 'completed with errors' : 'completed';
    log(`Done in ${elapsed}s with ${errors} error(s).`);
  }

  $('#start').addEventListener('click', uploadAll);
})();
</script>
</body>
</html>
